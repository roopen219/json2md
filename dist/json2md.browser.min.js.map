{"mappings":"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","sources":["<anon>","lib/index.js","lib/converters.js","node_modules/indento/lib/index.js"],"sourcesContent":["\"use strict\";\nvar $fe76a9f572e9e61e$exports = {};\n\"use strict\";\nconst $fe76a9f572e9e61e$var$converters = $fe76a9f572e9e61e$exports = {};\nlet $fe76a9f572e9e61e$var$generateHeader = (repeat)=>{\n    return (input, json2md)=>{\n        return \"#\".repeat(repeat) + \" \" + json2md(input);\n    };\n};\nlet $fe76a9f572e9e61e$var$indent = (content, spaces, ignoreFirst)=>{\n    let lines = content;\n    if (typeof content === \"string\") lines = content.split(\"\\n\");\n    if (ignoreFirst) {\n        if (lines.length <= 1) return lines.join(\"\\n\");\n        return lines[0] + \"\\n\" + $fe76a9f572e9e61e$var$indent(lines.slice(1), spaces, false);\n    }\n    return lines.map((c)=>\" \".repeat(spaces) + c).join(\"\\n\");\n};\nlet $fe76a9f572e9e61e$var$parseTextFormat = (text)=>{\n    let formats = {\n        strong: \"**\",\n        italic: \"*\",\n        underline: \"_\",\n        strikethrough: \"~~\",\n        code: \"`\"\n    };\n    return text.toString().replace(/<\\/?strong\\>/gi, formats.strong).replace(/<\\/?bold\\>/gi, formats.strong).replace(/<\\/?em\\>/gi, formats.italic).replace(/<\\/?italic\\>/gi, formats.italic).replace(/<\\/?u\\>/gi, formats.underline).replace(/<\\/?strike\\>/gi, formats.strikethrough).replace(/<\\/?code\\>/gi, formats.code);\n};\n// Headings\n$fe76a9f572e9e61e$var$converters.h1 = $fe76a9f572e9e61e$var$generateHeader(1);\n$fe76a9f572e9e61e$var$converters.h2 = $fe76a9f572e9e61e$var$generateHeader(2);\n$fe76a9f572e9e61e$var$converters.h3 = $fe76a9f572e9e61e$var$generateHeader(3);\n$fe76a9f572e9e61e$var$converters.h4 = $fe76a9f572e9e61e$var$generateHeader(4);\n$fe76a9f572e9e61e$var$converters.h5 = $fe76a9f572e9e61e$var$generateHeader(5);\n$fe76a9f572e9e61e$var$converters.h6 = $fe76a9f572e9e61e$var$generateHeader(6);\n$fe76a9f572e9e61e$var$converters.blockquote = (input, json2md)=>{\n    return json2md($fe76a9f572e9e61e$var$parseTextFormat(input), \"> \");\n};\n$fe76a9f572e9e61e$var$converters.img = (input, json2md)=>{\n    debugger;\n    if (Array.isArray(input)) return json2md(input, \"\", \"img\");\n    if (typeof input === \"string\") return $fe76a9f572e9e61e$var$converters.img({\n        source: input,\n        title: \"\",\n        alt: \"\"\n    });\n    input.title = input.title || \"\";\n    input.alt = input.alt || \"\";\n    return \"![\" + input.alt + \"](\" + input.source + ' \"' + input.title + '\")';\n};\n$fe76a9f572e9e61e$var$converters.ul = (input, json2md)=>{\n    let c = \"\";\n    for(let i = 0; i < input.length; ++i){\n        let marker = \"\";\n        let type = Object.keys(input[i])[0];\n        if (type !== \"ul\" && type !== \"ol\" && type !== \"taskLists\") marker += \"\\n - \";\n        c += marker + $fe76a9f572e9e61e$var$parseTextFormat($fe76a9f572e9e61e$var$indent(json2md(input[i]), 4, true));\n    }\n    return c;\n};\n$fe76a9f572e9e61e$var$converters.ol = (input, json2md)=>{\n    let c = \"\";\n    let jumpCount = 0;\n    for(let i = 0; i < input.length; ++i){\n        let marker = \"\";\n        let type = Object.keys(input[i])[0];\n        if (type !== \"ul\" && type !== \"ol\" && type !== \"taskLists\") marker = \"\\n \" + (i + 1 - jumpCount) + \". \";\n        else jumpCount++;\n        c += marker + $fe76a9f572e9e61e$var$parseTextFormat($fe76a9f572e9e61e$var$indent(json2md(input[i]), 4, true));\n    }\n    return c;\n};\n$fe76a9f572e9e61e$var$converters.taskLists = (input, json2md)=>{\n    let c = \"\";\n    for(let i = 0; i < input.length; ++i){\n        let marker = \"\";\n        let type = Object.keys(input[i])[0];\n        if (type !== \"ul\" && type !== \"ol\" && type !== \"taskLists\") marker += input[i].isDone ? \"\\n - [x] \" : \"\\n - [ ] \";\n        c += marker + $fe76a9f572e9e61e$var$parseTextFormat($fe76a9f572e9e61e$var$indent(json2md(input[i].title || input[i]), 4, true));\n    }\n    return c;\n};\n$fe76a9f572e9e61e$var$converters.code = (input, json2md)=>{\n    let c = \"```\" + (input.language || \"\") + \"\\n\";\n    if (Array.isArray(input.content)) c += input.content.join(\"\\n\");\n    else c += input.content;\n    c += \"\\n```\";\n    return c;\n};\n$fe76a9f572e9e61e$var$converters.p = (input, json2md)=>{\n    return $fe76a9f572e9e61e$var$parseTextFormat(json2md(input, \"\\n\"));\n};\n$fe76a9f572e9e61e$var$converters.table = (input, json2md)=>{\n    const ALIGNMENT = {\n        CENTER: \"center\",\n        RIGHT: \"right\",\n        LEFT: \"left\",\n        NONE: \"none\"\n    };\n    const PREFERRED_LENGTH_PER_ALIGNMENT = {\n        [ALIGNMENT.CENTER]: 3,\n        [ALIGNMENT.RIGHT]: 2,\n        [ALIGNMENT.LEFT]: 2,\n        [ALIGNMENT.NONE]: 1\n    };\n    if (typeof input !== \"object\" || !input.hasOwnProperty(\"headers\") || !input.hasOwnProperty(\"rows\")) return \"\";\n    const alignment = input.headers.map((_, index)=>input.aligns && input.aligns[index] ? input.aligns[index] : ALIGNMENT.NONE);\n    // try to match the space the column name and the dashes (and colons) take up. Minimum depends on alignment\n    const preferred_lengths = input.headers.map((header, index)=>Math.max(PREFERRED_LENGTH_PER_ALIGNMENT[alignment[index]], header.length - 2));\n    if (input.pretty === true) // update preferred_lengths considering rows' cells length\n    input.rows.forEach((row)=>{\n        (Array.isArray(row) ? row : input.headers.map((col_id)=>row[col_id])).forEach((cell, index)=>{\n            preferred_lengths[index] = Math.max(preferred_lengths[index], cell.length - 2);\n        });\n    });\n    const fill_right = function(diff, header) {\n        return \" \".repeat(diff) + header;\n    };\n    const fill_left = function(diff, header) {\n        return header + \" \".repeat(diff);\n    };\n    const fill_center = function(diff, header) {\n        return \" \".repeat(Math.floor(diff / 2)) + header + \" \".repeat(Math.ceil(diff / 2));\n    };\n    const fill_th = (header, index)=>{\n        const diff = preferred_lengths[index] + 2 - header.length;\n        switch(alignment[index]){\n            case ALIGNMENT.RIGHT:\n                return fill_right(diff, header);\n            case ALIGNMENT.LEFT:\n                return fill_left(diff, header);\n            case ALIGNMENT.CENTER:\n            case ALIGNMENT.NONE:\n            default:\n                return fill_center(diff, header);\n        }\n    };\n    const fill_td = (header, index)=>{\n        const diff = preferred_lengths[index] + 2 - header.length;\n        switch(alignment[index]){\n            case ALIGNMENT.RIGHT:\n                return fill_right(diff, header);\n            case ALIGNMENT.NONE:\n            case ALIGNMENT.LEFT:\n                return fill_left(diff, header);\n            case ALIGNMENT.CENTER:\n            default:\n                return fill_center(diff, header);\n        }\n    };\n    // add spaces around column name if necessary (side(s) depends on alignment)\n    const column_names = input.headers.map(fill_th);\n    const header = \"| \" + column_names.join(\" | \") + \" |\";\n    const spaces = \"| \" + input.headers.map((_, index)=>{\n        const inner = \"-\".repeat(preferred_lengths[index]);\n        switch(alignment[index]){\n            case ALIGNMENT.CENTER:\n                return \":\" + inner + \":\";\n            case ALIGNMENT.RIGHT:\n                return \"-\" + inner + \":\";\n            case ALIGNMENT.LEFT:\n                return \":\" + inner + \"-\";\n            case ALIGNMENT.NONE:\n            default:\n                return \"-\" + inner + \"-\";\n        }\n    }).join(\" | \") + \" |\";\n    const fill_tbody_cell = (cell, index)=>{\n        if (input.pretty !== true) return cell;\n        return fill_td(cell, index);\n    };\n    const data = input.rows.map((row)=>\"| \" + (Array.isArray(row) ? row : input.headers.map((col_id)=>row[col_id])).map((cell)=>json2md(cell)).map((cell)=>$fe76a9f572e9e61e$var$parseTextFormat(cell)).map((cell)=>cell.replace(/([^\\\\])\\|/, \"$1\\\\|\")).map((cell)=>cell.trim()).map(fill_tbody_cell).join(\" | \") + \" |\").join(\"\\n\");\n    return [\n        header,\n        spaces,\n        data\n    ].join(\"\\n\");\n};\n$fe76a9f572e9e61e$var$converters.link = (input, json2md)=>{\n    if (Array.isArray(input)) return json2md(input, \"\", \"link\");\n    if (typeof input === \"string\") return $fe76a9f572e9e61e$var$converters.link({\n        source: input,\n        title: \"\"\n    });\n    return \"[\" + input.title + \"](\" + input.source + \")\";\n};\n$fe76a9f572e9e61e$var$converters.hr = (input, json2md)=>{\n    return \"---\";\n};\n\n\nvar $56f45a4e529931ce$exports = {};\n\"use strict\";\n/**\n * indento\n * Indents the input string.\n *\n * @name indento\n * @function\n * @param {String} input The input string.\n * @param {Number} width The indent width.\n * @param {String} char The character to use for indentation (default: `\" \"`).\n * @return {String} The indented string.\n */ function $56f45a4e529931ce$var$indento(input, width, char) {\n    char = typeof char !== \"string\" ? \" \" : char;\n    return String(input).replace(/^/gm, char.repeat(width));\n}\n$56f45a4e529931ce$exports = $56f45a4e529931ce$var$indento;\n\n\nfunction $8bb218936d9f38ba$var$json2md(data, prefix, _type) {\n    prefix = prefix || \"\";\n    if (typeof data === \"string\" || typeof data === \"number\") return $56f45a4e529931ce$exports(data, 1, prefix);\n    let content = [];\n    // Handle arrays\n    if (Array.isArray(data)) {\n        for(let i = 0; i < data.length; ++i)content.push($56f45a4e529931ce$exports($8bb218936d9f38ba$var$json2md(data[i], \"\", _type), 1, prefix));\n        return content.join(\"\\n\");\n    } else if (_type) {\n        let mdText = \"\";\n        let func = $fe76a9f572e9e61e$exports[_type || type];\n        if (typeof func === \"function\") mdText += $56f45a4e529931ce$exports(func(_type ? data : data[type], $8bb218936d9f38ba$var$json2md), 1, prefix) + \"\\n\";\n        else throw new Error(\"There is no such converter: \" + type);\n        return mdText;\n    } else {\n        let mdText = \"\";\n        Object.keys(data).forEach((type1, index, array)=>{\n            let func = $fe76a9f572e9e61e$exports[_type || type1];\n            if (typeof func === \"function\") mdText += $56f45a4e529931ce$exports(func(_type ? data : data[type1], $8bb218936d9f38ba$var$json2md), 1, prefix) + \"\\n\";\n            else throw new Error(\"There is no such converter: \" + type1);\n        });\n        return mdText;\n    }\n}\n$8bb218936d9f38ba$var$json2md.async = (data, prefix, _type)=>Promise.resolve().then(()=>{\n        prefix = prefix || \"\";\n        if (typeof data === \"string\" || typeof data === \"number\") return $56f45a4e529931ce$exports(data, 1, prefix);\n        let content = [];\n        if (Array.isArray(data)) {\n            const promises = data.map((d, index)=>Promise.resolve().then(()=>$8bb218936d9f38ba$var$json2md.async(d, \"\", _type)).then((result)=>$56f45a4e529931ce$exports(result, 1, prefix)).then((result)=>{\n                    content[index] = result;\n                }));\n            return Promise.all(promises).then(()=>content.join(\"\\n\"));\n        } else {\n            let type1 = Object.keys(data)[0], func = $fe76a9f572e9e61e$exports[_type || type1];\n            if (typeof func === \"function\") return Promise.resolve().then(()=>func(_type ? data : data[type1], $8bb218936d9f38ba$var$json2md)).then((result)=>$56f45a4e529931ce$exports(result, 1, prefix) + \"\\n\");\n            throw new Error(\"There is no such converter: \" + type1);\n        }\n    });\n$8bb218936d9f38ba$var$json2md.converters = $fe76a9f572e9e61e$exports;\nmodule.exports = $8bb218936d9f38ba$var$json2md;\n\n\n//# sourceMappingURL=json2md.browser.min.js.map\n","\"use strict\"\n\nconst converters = require(\"./converters\")\n    , indento = require(\"indento\")\nfunction json2md(data, prefix, _type) {\n    prefix = prefix || \"\"\n    if (typeof data === \"string\" || typeof data === \"number\") {\n        return indento(data, 1, prefix)\n    }\n\n    let content = []\n\n    // Handle arrays\n    if (Array.isArray(data)) {\n        for (let i = 0; i < data.length; ++i) {\n            content.push(indento(json2md(data[i], \"\", _type), 1, prefix))\n        }\n        return content.join(\"\\n\")\n    } else if (_type) {\n    \tlet mdText = \"\";\n        let func = converters[_type || type];\n        if (typeof func === \"function\") {\n            mdText += indento(func(_type ? data : data[type], json2md), 1, prefix) + \"\\n\";\n        } else {\n            throw new Error(\"There is no such converter: \" + type);\n        }\n        return mdText\n    } else {\n    \tlet mdText = \"\";\n        Object.keys(data).forEach((type, index, array) => {\n            let func = converters[_type || type];\n\n            if (typeof func === \"function\") {\n                mdText += indento(func(_type ? data : data[type], json2md), 1, prefix) + \"\\n\";\n            } else {\n                throw new Error(\"There is no such converter: \" + type);\n            }\n        });\n        return mdText;\n    }\n}\njson2md.async = (data, prefix, _type) => Promise.resolve().then(() => {\n    prefix = prefix || \"\"\n    if (typeof data === \"string\" || typeof data === \"number\") {\n        return indento(data, 1, prefix)\n    }\n\n    let content = []\n\n    if (Array.isArray(data)) {\n        const promises = data.map((d, index) => Promise.resolve()\n            .then(() => json2md.async(d, \"\", _type))\n            .then((result) => indento(result, 1, prefix))\n            .then((result) => {\n                content[index] = result;\n            })\n        )\n        return Promise.all(promises).then(() => content.join(\"\\n\"))\n    } else {\n        let type = Object.keys(data)[0]\n          , func = converters[_type || type]\n\n        if (typeof func === \"function\") {\n            return Promise.resolve()\n                .then(() => func(_type ? data : data[type], json2md))\n                .then((result) => indento(result, 1, prefix) + \"\\n\")\n        }\n        throw new Error(\"There is no such converter: \" + type)\n    }\n})\n\njson2md.converters = converters\n\nmodule.exports = json2md\n","\"use strict\"\n\nconst converters = module.exports = {}\n\nlet generateHeader = repeat => {\n    return (input, json2md) => {\n        return \"#\".repeat(repeat) + \" \" + json2md(input)\n    }\n}\n\nlet indent = (content, spaces, ignoreFirst) => {\n    let lines = content\n\n    if (typeof content === \"string\") {\n        lines = content.split(\"\\n\")\n    }\n\n    if (ignoreFirst) {\n        if (lines.length <= 1) {\n            return lines.join(\"\\n\")\n        }\n        return lines[0] + \"\\n\" + indent(lines.slice(1), spaces, false)\n    }\n\n    return lines.map(c => \" \".repeat(spaces) + c).join(\"\\n\")\n}\n\nlet parseTextFormat = text => {\n\n    let formats = {\n        strong: \"**\"\n      , italic: \"*\"\n      , underline: \"_\"\n      , strikethrough: \"~~\"\n      , code: \"`\"\n    }\n\n    return text\n            .toString()\n            .replace(/<\\/?strong\\>/gi, formats.strong)\n            .replace(/<\\/?bold\\>/gi, formats.strong)\n            .replace(/<\\/?em\\>/gi, formats.italic)\n            .replace(/<\\/?italic\\>/gi, formats.italic)\n            .replace(/<\\/?u\\>/gi, formats.underline)\n            .replace(/<\\/?strike\\>/gi, formats.strikethrough)\n            .replace(/<\\/?code\\>/gi, formats.code)\n\n}\n\n// Headings\nconverters.h1 = generateHeader(1)\nconverters.h2 = generateHeader(2)\nconverters.h3 = generateHeader(3)\nconverters.h4 = generateHeader(4)\nconverters.h5 = generateHeader(5)\nconverters.h6 = generateHeader(6)\n\nconverters.blockquote = (input, json2md) => {\n    return json2md(parseTextFormat(input), \"> \")\n}\n\nconverters.img = (input, json2md) => {\n\n    debugger\n    if (Array.isArray(input)) {\n        return json2md(input, \"\", \"img\")\n    }\n    if (typeof input === \"string\") {\n        return converters.img({ source: input, title: \"\", alt: \"\"})\n    }\n    input.title = input.title || \"\"\n    input.alt = input.alt || \"\"\n    return \"![\" + input.alt + \"](\" + input.source + \" \\\"\" + input.title + \"\\\")\"\n}\n\nconverters.ul = (input, json2md) => {\n    let c = \"\"\n    for (let i = 0; i < input.length; ++i) {\n        let marker = \"\"\n\n        let type = Object.keys(input[i])[0]\n        if(type !== \"ul\" && type !== \"ol\" && type !== 'taskLists'){\n          marker += \"\\n - \"\n        }\n\n        c += marker + parseTextFormat(indent(json2md(input[i]), 4, true))\n    }\n    return c\n}\n\nconverters.ol = (input, json2md) => {\n    let c = \"\"\n    let jumpCount = 0\n    for (let i = 0; i < input.length; ++i) {\n        let marker = \"\"\n        let type = Object.keys(input[i])[0]\n        if(type !== \"ul\" && type !== \"ol\" && type !== 'taskLists'){\n          marker = \"\\n \" + (i + 1 - jumpCount) + \". \"\n        } else {\n          jumpCount++\n        }\n\n        c += marker + parseTextFormat(indent(json2md(input[i]), 4, true))\n    }\n    return c\n}\n\nconverters.taskLists = (input, json2md) => {\n    let c = \"\"\n    for (let i = 0; i < input.length; ++i) {\n        let marker = \"\"\n\n        let type = Object.keys(input[i])[0]\n        if(type !== \"ul\" && type !== \"ol\" && type !== 'taskLists'){\n            marker += input[i].isDone ? \"\\n - [x] \" : \"\\n - [ ] \"\n        }\n\n        c += marker + parseTextFormat(indent(json2md(input[i].title || input[i]), 4, true))\n    }\n    return c\n}\n\nconverters.code = (input, json2md) => {\n    let c = \"```\" + (input.language || \"\") + \"\\n\"\n    if (Array.isArray(input.content)) {\n        c += input.content.join(\"\\n\")\n    } else {\n        c += input.content\n    }\n    c += \"\\n```\"\n    return c\n}\n\nconverters.p = (input, json2md) => {\n    return parseTextFormat(json2md(input, \"\\n\"))\n}\n\nconverters.table = (input, json2md) => {\n\n    const ALIGNMENT = {\n          CENTER: 'center'\n        , RIGHT: 'right'\n        , LEFT: 'left'\n        , NONE: 'none'\n    }\n\n    const PREFERRED_LENGTH_PER_ALIGNMENT = {\n          [ALIGNMENT.CENTER]: 3\n        , [ALIGNMENT.RIGHT]: 2\n        , [ALIGNMENT.LEFT]: 2\n        , [ALIGNMENT.NONE]: 1\n    }\n\n    if (typeof input !== \"object\"\n        || !input.hasOwnProperty(\"headers\")\n        || !input.hasOwnProperty(\"rows\")) {\n        return \"\"\n    }\n\n    const alignment = input.headers.map((_, index) => input.aligns && input.aligns[index]\n        ? input.aligns[index]\n        : ALIGNMENT.NONE\n    )\n\n    // try to match the space the column name and the dashes (and colons) take up. Minimum depends on alignment\n    const preferred_lengths = input.headers.map((header, index) => Math.max(\n        PREFERRED_LENGTH_PER_ALIGNMENT[alignment[index]],\n        header.length - 2\n    ))\n\n    if (input.pretty === true) {\n        // update preferred_lengths considering rows' cells length\n        input.rows.forEach(row => {\n            (Array.isArray(row) ? row : input.headers.map(col_id => row[col_id]))\n                .forEach((cell, index) => {\n                    preferred_lengths[index] = Math.max(preferred_lengths[index], cell.length-2)\n                })\n        })\n    }\n\n    const fill_right = function(diff, header) {\n        return \" \".repeat(diff) + header;\n    }\n    const fill_left = function(diff, header) {\n        return header + \" \".repeat(diff);\n    }\n    const fill_center = function(diff, header) {\n        return \" \".repeat(Math.floor(diff/2)) + header + \" \".repeat(Math.ceil(diff/2));\n    }\n\n    const fill_th = (header, index) => {\n        const diff = preferred_lengths[index]+2 - header.length;\n        switch (alignment[index]) {\n            case ALIGNMENT.RIGHT:   return fill_right(diff, header);\n            case ALIGNMENT.LEFT:    return fill_left(diff, header);\n            case ALIGNMENT.CENTER:\n            case ALIGNMENT.NONE:\n            default:                return fill_center(diff, header);\n        }\n    };\n\n    const fill_td = (header, index) => {\n        const diff = preferred_lengths[index]+2 - header.length;\n        switch (alignment[index]) {\n            case ALIGNMENT.RIGHT:   return fill_right(diff, header);\n            case ALIGNMENT.NONE:\n            case ALIGNMENT.LEFT:    return fill_left(diff, header);\n            case ALIGNMENT.CENTER:\n            default:                return fill_center(diff, header);\n        }\n    };\n\n    // add spaces around column name if necessary (side(s) depends on alignment)\n    const column_names = input.headers.map(fill_th)\n\n    const header = \"| \" + column_names.join(\" | \") + \" |\";\n\n    const spaces = \"| \" + input.headers.map((_, index) => {\n        const inner = \"-\".repeat(preferred_lengths[index])\n        switch (alignment[index]) {\n            case ALIGNMENT.CENTER:  return \":\" + inner + \":\";\n            case ALIGNMENT.RIGHT:   return \"-\" + inner + \":\";\n            case ALIGNMENT.LEFT:    return \":\" + inner + \"-\";\n            case ALIGNMENT.NONE:\n            default:                return \"-\" + inner + \"-\";\n        }\n    }).join(\" | \") + \" |\";\n\n    const fill_tbody_cell = (cell, index) => {\n        if(input.pretty !== true) return cell;\n        return fill_td(cell, index);\n    }\n\n    const data  = input.rows.map(row =>\n        \"| \" + (Array.isArray(row) ? row : input.headers.map(col_id => row[col_id]))\n            .map(cell => json2md(cell))\n            .map(cell => parseTextFormat(cell))\n            .map(cell => cell.replace(/([^\\\\])\\|/, \"$1\\\\|\"))\n            .map(cell => cell.trim())\n            .map(fill_tbody_cell)\n            .join(\" | \")  + \" |\"\n    ).join(\"\\n\");\n\n    return [header, spaces, data].join(\"\\n\")\n}\n\nconverters.link = (input, json2md) => {\n    if (Array.isArray(input)) {\n        return json2md(input, \"\", \"link\")\n    }\n    if (typeof input === \"string\") {\n        return converters.link({ source: input, title: \"\" })\n    }\n    return \"[\" + input.title + \"](\" + input.source + \")\"\n}\n\nconverters.hr = (input, json2md) => {\n    return '---'\n}\n","\"use strict\";\n\n/**\n * indento\n * Indents the input string.\n *\n * @name indento\n * @function\n * @param {String} input The input string.\n * @param {Number} width The indent width.\n * @param {String} char The character to use for indentation (default: `\" \"`).\n * @return {String} The indented string.\n */\nfunction indento(input, width, char) {\n  char = typeof char !== \"string\" ? \" \" : char;\n  return String(input).replace(/^/gm, char.repeat(width));\n}\n\nmodule.exports = indento;"],"names":["$fe76a9f572e9e61e$exports","$fe76a9f572e9e61e$var$converters","$fe76a9f572e9e61e$var$generateHeader","repeat","input","json2md","$fe76a9f572e9e61e$var$indent","content","spaces","ignoreFirst","lines","split","length","join","slice","map","c","$fe76a9f572e9e61e$var$parseTextFormat","text","formats","strong","italic","underline","strikethrough","code","toString","replace","h1","h2","h3","h4","h5","h6","blockquote","img","Array","isArray","source","title","alt","ul","i","marker","type","Object","keys","ol","jumpCount","taskLists","isDone","language","p","table","ALIGNMENT","CENTER","RIGHT","LEFT","NONE","PREFERRED_LENGTH_PER_ALIGNMENT","hasOwnProperty","alignment","headers","_","index","aligns","preferred_lengths","header","Math","max","pretty","rows","forEach","row","col_id","cell","fill_right","diff","fill_left","fill_center","floor","ceil","fill_td","column_names","inner","fill_tbody_cell","data","trim","link","hr","$56f45a4e529931ce$exports","$8bb218936d9f38ba$var$json2md","prefix","_type","push","mdText","func","Error","type1","array","width","char","String","async","Promise","resolve","then","promises","d","result","all","converters","module","exports"],"version":3,"file":"json2md.browser.min.js.map"}